- this works:

	irb(main):001:0> require 'vips8'
	=> true
	irb(main):004:0> x = Vips::Image.new
	=> #<Vips::Image:0x00000001f3cea0 @struct=#<Vips::Image::Struct:0x00000001f3ce78>>
	irb(main):006:0> x = nil
	=> nil
	irb(main):007:0> GC.start
	=> nil
	irb(main):009:0> Vips::Object::print_all
	=> nil

  this does not:

	irb(main):001:0> require 'vips8'
	=> true
	irb(main):006:0> im = Vips::Image.new_from_file "/data/john/pics/k2.jpg"
	=> #<Vips::Image:0x000000028a9588 @struct=#<Vips::Image::Struct:0x000000028a94e8>>
	irb(main):010:0> im = nil
	=> nil
	irb(main):012:0> GC.start
	=> nil
	irb(main):013:0> Vips::Object::print_all
	2 objects alive:
	0) VipsImage (0x31d1020) 1080 bytes
	VipsImage (image), image class 1450x2048 uchar, 3 bands, srgb, jpegload
	1) VipsForeignLoadJpegFile (0x2b47030)
	VipsForeignLoadJpegFile (jpegload), load jpeg from file (.jpg, .jpeg, .jpe),
	priority=0, is_a, get_flags, get_flags_filename, header, load jpegload
	filename="/data/john/pics/k2.jpg" out=((VipsImage*) 0x31d1020) -
	=> nil

  step by step:

  	im = Vips::call "jpegload", "/data/john/pics/k2.jpg"

  same

	require 'vips8'
	Vips::cache_set_max 0 
  	op = Vips::Operation.new "jpegload"
	op.set_property "filename", "/data/john/pics/k2.jpg"
	op2 = Vips::cache_operation_build op

	image count 1, jpegload count 3

  Vips::cache_operation_build is reffing the operation an extra time? is it
  ignoring the (transfer full) annotation?

  trace in gdb ... when does the extra ref get added?

	break at vips_cache_operation_build ... count == 1

	vips_cache_operation_build() reffs orig_operation ... count 2

	vips_cache_operation_buildp() reffs again, the output image now holds
	a ref to the operation ... count 3

  and that's it, we have our three refs

  are more refs added and then removed?

  what if you do 

  	op3 = op2

  does operation get another ref? or do all vars "share" a single reference
  to the object? I guess they share

  if they do, do we have to add lots of explicit unrefs ourselves? there must
  be a single ruby reference for every object

  try again

  	require 'gir_ffi'
	GirFFI.setup :Vips
	Vips::init($PROGRAM_NAME)
	Vips::cache_set_max 0
	op = Vips::Operation.new "jpegload"
	op.set_property "filename", "/data/john/pics/k2.jpg"
	Vips::Object::print_all

	op has count 1

	op2 = Vips::cache_operation_build op
	Vips::Object::print_all

	image has count 1, op has count 3
	1 count is a ref on the original object
	1 count is the ref that op2 owns
	1 count is a ref from image

	GObject::Lib.g_object_unref op
	op = nil

	image has count 1, op has count 2

	out = op2.property("out").get_value

	image has count 2, op has count 2

	op2.unref_outputs

	image has count 1, op has count 2 ... op2 is the final ref, we'll
	unref on next GC

	use .to_ptr to see if two objects share an underlying gobject pointer



- example.rb with 100 iterations ... 3500 objects, 200 allocations

  example.rb with 200 iterations ... 7000 objects, 400 allocations


  

- what about docs for VipsPrecision etc. ? can we just refer to the libvips
  API docs? we do that for VipsAccess in the intro

- something to make a VipsInterpolate from a symbol? try calling affine and
  setting an interpolator

	x = Vips::Interpolate.new "bilinear"

  works ... try adding code to set_value

  add a note on this to the intro

- test suite

  just test binding, no need to test vips

- why doesn't this example code work?

# == Command-line option parsing
#
# GLib includes a command-line option parser, and libvips defines a set of 
# standard flags you can use with it. For example:
#
#   require 'vips8'
#
#   context = GLib::OptionContext.new " - test stuff"
#   main_group = GLib::OptionGroup "main", 
#     "Main options", "Main options for this program", nil
#   context.set_main_group main_group
#   Vips::add_option_entries main_group
#   context.parse ARGV
#
